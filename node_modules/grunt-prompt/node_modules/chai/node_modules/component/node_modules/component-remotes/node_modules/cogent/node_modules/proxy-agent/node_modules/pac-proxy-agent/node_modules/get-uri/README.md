get-uri
=======
### Returns a `stream.Readable` from a URI string
[![Build Status](https://travis-ci.org/TooTallNate/node-get-uri.png?branch=master)](https://travis-ci.org/TooTallNate/node-get-uri)

This high-level module accepts a URI string and returns a `Readable` stream
instance. There is built-in support for a variety of "protocols", and it's
easily extensible with more:

| Protocol  | Description                     | Example
|:---------:|:-------------------------------:|:---------------------------------:
| `data`    | [Data URIs][data]               | `data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D`
| `file`    | [File URIs][file]               | `file:///c:/windows/example.ini`
| `ftp`     | [FTP URIs][ftp]                 | `ftp://ftp.kernel.org/pub/site/README`
| `http`    | [HTTP URIs][http]               | `http://www.example.com/path/to/name`
| `https`   | [HTTPS URIs][https]             | `https://www.example.com/path/to/name`


Installation
------------

Install with `npm`:

``` bash
$ npm install get-uri
```


Example
-------

To simply get a `stream.Readable` instance from a `file:` URI, try something like:

``` js
var getUri = require('get-uri');

// `file:` maps to a `fs.ReadStream` instance…
getUri('file:///Users/nrajlich/wat.json', function (err, rs) {
  if (err) throw err;
  rs.pipe(process.stdout);
});
```


Missing Endpoints
-----------------

When you pass in a URI in which the resource referenced does not exist on the
destination server, then a `NotFoundError` will be returned. The `code` of the
error instance is set to `"ENOTFOUND"`, so you can special-case that in your code
to detect when a bad filename is requested:

``` js
getUri('http://example.com/resource.json', function (err, rs) {
  if (err) {
    if ('ENOTFOUND' == err.code) {
      // bad file path requested
    } else {
      // something else bad happened...
      throw err;
    }
  }

  // your app code…
});
```


Cacheability
------------

When calling `getUri()` with the same URI multiple times, the `get-uri` module
supports sending an indicator that the remote resource has not been modified
since the last time it has been retreived from that node process.

To do this, pass in a `cache` option to the "options object" argument
with the value set to the `stream.Readable` instance that was previously
returned. If the remote resource has not been changed since the last call for
that same URI, then a `NotModifiedError` instance will be returned with it's
`code` property set to `"ENOTMODIFIED"`.

When the `"ENOTMODIFIED"` error occurs, then you can safely re-use the
results from the previous `getUri()` call for that same URI:

``` js
// maps to a `fs.ReadStream` instance
getUri('http://example.com/resource.json', function (err, rs) {
  if (err) throw err;

  // … some time later, if you need to get this same URI again, pass in the
  // previous `stream.Readable` instance as `cache` option to potentially
  // receive an "ENOTMODIFIED" response:
  getUri('http://example.com/resource.json', function (err, rs2) {
    if (err) {
      if ('ENOTFOUND' == err.code) {
        // bad file path requested
      } else if ('ENOTMODIFIED' == err.code) {
        // source file has not been modified since last time it was requested,
        // so `rs2` is undefined and you are expected to re-use results from
        // a previous call to `getUri()`
      } else {
        // something else bad happened...
        throw err;
      }
    }
  });
});
```


API
---

### getUri(String uri[, Object options,] Function callback)

A `uri` String is 